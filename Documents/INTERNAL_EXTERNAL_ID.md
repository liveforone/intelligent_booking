# 내부식별자와 외부 식별자 구분

## pk를 외부로 노출
* 필자는 pk를 순차적 pk, 즉 auto increment를 썻다.
* pk를 외부로 노출하는 경우가 참 많다. 필자도 그러했다.
* 항상 고민이 들었던것은 사용자가 악의적으로 조작할 수 없을까?
* 특히나 중요한 로직이라면 더더욱 어쩌지? 라는 고민이 계속 들었다.
* 또한 너무나 pk가 단순해서 pk만으로는 업데이트를 하지 않고, 사용자가 해당 데이터의 주인이 맞는지 매번 검증했다.
* 이러한 스트레스를 해결하고 싶었다.

## 외부 식별자를 만들자
* 외부식별자는 좋은 해결책이다.
* 다만 조건이 있다. 눈으로 알아볼 수 없어야하며, 즉 보안에 유리해야한다.
* 또한 검증이 필요없을 정도로 복잡해야하는 조건이 있다.

## UUID
* uuid는 이러한 조건에 딱 부합하는 것이었다.
* 총 36개의 문자로 구성된 uuid는 상당히 복잡하고 눈으로 의미를 파악하기 어려웠다.
* 또한 후보키로의 조건, 즉 유일성이 보장되는 것이었다.
* 유일성의 경우 unique 제약을 걸게되면 같은 값이 혹시나 들어갈경우 data integrity exception이 터지므로 걱정이없었다.

## uuid 사용범위
* 이러한 외부 식별자는 말그래도 외부에 사용된다.
* api에 파라미터로 받거나, 전달하는 데에 사용된다.
* 클라이언트는 이 uuid를 가지고 조회/수정 등을 요청한다.
* 다만 uuid는 후술할 단점으로 인해 fk로는 사용하지 않았다.

## pk의 사용범위
* pk의 사용범위는 아래와 같다.
* 내부 시스템 관리, 즉 조인/fk/백업/복구/내부작업 등에 사용한다.
* 이외에는 절대로 pk를 외부로 노출시키지 않는다.

## 단점
* 필자의 경우 소팅은 pk를 사용했기 때문에 소팅과 관련한 문제는 없다.
* 다만 uuid는 용량이 크다. 8바이트의 BigDecemal 보다 훨씬 크다.
* 이외에도 가독성 나쁨, 정렬 안됨 이라는 단점이 있지만 필자에게는 의미없다.
* 다만 큰 용량 때문에 조회시 사용하게 되면 성능이 pk보다는 떨어진다. 
* 아니 pk가 아니더라도 똑같이 유니크 제약이 걸린 정수형 후보키보다 성능이 떨어진다.
* 그래도 인덱스를 걸어 성능을 높이고, 위에서 서술한 장점을 위해 사용하도록 한다.

## 높은 확장성
* 위에서 서술하지 않은 장점이 있다. 바로 높은 확장성이다.
* 기존에 msa 어플리케이션을 개발한 적이 있다. 이러한 분산 시스템의 경우 확장성있는 설계, 구조가 아주 중요하다.
* 그렇지 않으면 중복되는 기능의 함수, 라이브러리 등이 사용된다.
* 이러한 문제로 중복 문제로 인해서 확장성 있는 설계, 종속이 없는 설계와 구조가 얼마나 중요한지 깨닫게 되었다.
* uuid는 걱정없이 api파라미터, 혹은 json body로 전달받아서 사용하기만 하면된다.
* 따라서 높은 확장성을 가지게 되고, 향후 시스템을 분산 환경이나, 대규모 트래픽에 더욱 용이한 환경으로 리팩토링할때
* 많은 변경이나 문제없이 원활히 리팩토링 할 수 있다.

## mysql 사용시 주의점
* uuid는 바이너리 16 타입으로 저장해야한다.
* 16을 넘어가면 다 패딩으로 mysql이 채워버려서, 파싱이까다롭다. 반드시 binary 16을 쓰자. 32 안된다.
* 이외에 varchar같은 타입도 남는 부분을 다 패딩으로 채워버린다. 이왕이면 바이너리 16으로 설정하여 관리하자.
* 또한 varchar는 크기도 크다...

## 결론
* 이를 통해 데이터 주인 검증, 사용자의 악의적 조작 차단, 여러 pk를 이용한 보안 위협에서 벗어날 수 있게 되었다.
* 컬럼 하나가 추가된데에 반해, 가져오는 장점은 상당히 많다.